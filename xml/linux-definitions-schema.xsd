<?xml version="1.0" encoding="utf-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:linux-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux" xmlns:sch="http://purl.oclc.org/dsdl/schematron" targetNamespace="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux" elementFormDefault="qualified" version="5.8">
     <xsd:import namespace="http://oval.mitre.org/XMLSchema/oval-definitions-5" schemaLocation="oval-definitions-schema.xsd"/>
     <xsd:import namespace="http://oval.mitre.org/XMLSchema/oval-common-5" schemaLocation="oval-common-schema.xsd"/>
     <xsd:annotation>
          <xsd:documentation>The following is a description of the elements, types, and attributes that compose the Linux specific tests found in Open Vulnerability and Assessment Language (OVAL). Each test is an extension of the standard test element defined in the Core Definition Schema. Through extension, each test inherits a set of elements and attributes that are shared amongst all OVAL tests. Each test is described in detail and should provide the information necessary to understand what each element and attribute represents. This document is intended for developers and assumes some familiarity with XML. A high level description of the interaction between the different tests and their relationship to the Core Definition Schema is not outlined here.</xsd:documentation>
          <xsd:documentation>The OVAL Schema is maintained by The MITRE Corporation and developed by the public OVAL Community. For more information, including how to get involved in the project and how to submit change requests, please visit the OVAL website at http://oval.mitre.org.</xsd:documentation>
          <xsd:appinfo>
               <schema>Linux Definition</schema>
               <version>5.8 Release Candidate 1</version>
               <date>8/19/2010 10:28:49 AM</date>
                <terms_of_use>Copyright (c) 2002-2010, The MITRE Corporation. All rights reserved.  The contents of this file are subject to the terms of the OVAL License located at http://oval.mitre.org/oval/about/termsofuse.html. See the OVAL License for the specific language governing permissions and limitations for use of this schema.  When distributing copies of the OVAL Schema, this license header must be included.</terms_of_use>
               <sch:ns prefix="oval-def" uri="http://oval.mitre.org/XMLSchema/oval-definitions-5"/>
               <sch:ns prefix="linux-def" uri="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"/>
               <sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/>
          </xsd:appinfo>
     </xsd:annotation>
     <!-- =============================================================================== -->
     <!-- ==============================  DPKG INFO TEST  =============================== -->
     <!-- =============================================================================== -->
     <xsd:element name="dpkginfo_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The dpkginfo test is used to check information for a given DPKG package. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a dpkginfo_object and the optional state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>dpkginfo_test</oval:test>
                         <oval:object>dpkginfo_object</oval:object>
                         <oval:state>dpkginfo_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">dpkginfo_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_dpkginfo_test">
                         <sch:rule context="linux-def:dpkginfo_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:dpkginfo_object/@id"><sch:value-of select="../@id"/> - the object child element of an dpkginfo_test must reference an dpkginfo_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:dpkginfo_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:dpkginfo_state/@id"><sch:value-of select="../@id"/> - the state child element of an dpkginfo_test must reference an dpkginfo_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="dpkginfo_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The dpkginfo_object element is used by a dpkginfo test to define the object to be evaluated. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
               <xsd:documentation>A dpkginfo object consists of a single name entity that identifies the package being checked.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the package name to check.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="dpkginfo_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The dpkginfo_state element defines the different information that can be used to evaluate the specified DPKG package. This includes the architecture, epoch number, release, and version numbers. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the DPKG package name to check.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="arch" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the architecture for which the package was built, like : i386, ppc, sparc, noarch.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="epoch" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the epoch number of the DPKG. For a null epoch (or '(none)' as returned by dpkg) the string '(none)' should be used.</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="int"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="release" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the release number of the build, changed by the vendor/builder.</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="version"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="version" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the version number of the build.</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="version"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="evr" type="oval-def:EntityStateEVRStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE".</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- =============================  IF LISTENERS TEST  ============================= -->
     <!-- =============================================================================== -->
     <xsd:element name="iflisteners_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The iflisteners_test is used to check what applications such as packet sniffers that are bound to an interface on the system. This is limited to applications that are listening on AF_PACKET sockets. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an iflisteners_object and the optional iflisteners_state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>iflisteners_test</oval:test>
                         <oval:object>iflisteners_object</oval:object>
                         <oval:state>iflisteners_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">iflisteners_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_iflisteners_test">
                         <sch:rule context="linux-def:iflisteners_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:iflisteners_object/@id"><sch:value-of select="../@id"/> - the object child element of an iflisteners_test must reference an iflisteners_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:iflisteners_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:iflisteners_state/@id"><sch:value-of select="../@id"/> - the state child element of an iflisteners_test must reference an iflisteners_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="iflisteners_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The iflisteners_object element is used by an iflisteners_test to define the specific interface to be evaluated. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="interface_name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The interface_name entity specifies the name of the interface (eth0, eth1, fw0, etc.) to check.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="iflisteners_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The iflisteners_state element defines the different information that can be used to evaluate the specified applications that are listening on interfaces on the system. This includes the interface name, protocol, hardware address, program name, pid, and user id. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="interface_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the name of the interface (eth0, eth1, fw0, etc.).</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="protocol" type="linux-def:EntityStateProtocolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the physical layer protocol used by the AF_PACKET socket.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="hw_address" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the hardware address associated with the interface.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="program_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the name of the communicating program.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="pid" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The pid is the process ID of a specific process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="user_id" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The numeric user id, or uid, is the third column of each user's entry in /etc/passwd. It represents the owner, and thus privilege level, of the specified program.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ========================  INET LISTENING SERVERS TEST  ======================== -->
     <!-- =============================================================================== -->
     <xsd:element name="inetlisteningservers_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The inet listening servers test is used to check what applications are listening on the network.  This is limited to applications that are listening for connections that use the TCP or UDP protocols and have addresses represented as IPv4 or IPv6 addresses (AF_INET or AF_INET6). It is generally using the parsed output of running the command netstat -tuwlnpe with root privilege. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an inetlisteningservers_object and the optional state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>inetlisteningservers_test</oval:test>
                         <oval:object>inetlisteningservers_object</oval:object>
                         <oval:state>inetlisteningservers_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">inetlisteningserver_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_inetlisteningservers_test">
                         <sch:rule context="linux-def:inetlisteningservers_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:inetlisteningservers_object/@id"><sch:value-of select="../@id"/> - the object child element of an inetlisteningservers_test must reference an inetlisteningservers_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:inetlisteningservers_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:inetlisteningservers_state/@id"><sch:value-of select="../@id"/> - the state child element of an inetlisteningservers_test must reference an inetlisteningservers_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="inetlisteningservers_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The inetlisteningservers_object element is used by an inet listening servers test to define the specific protocol-address-port to be evaluated. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
               <xsd:documentation>An inet listening servers object consists of three entities. The first identifies a specific IP address. The second entity represents a certain port number. While the third identifies the protocol.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="protocol" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The protocol entity defines a certain transport-layer protocol, in lowercase: tcp or udp.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element name="local_address" type="oval-def:EntityObjectIPAddressStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the IP address of the network interface on which an application listens. Note that the IP address can be IPv4 or IPv6.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element name="local_port" type="oval-def:EntityObjectIntType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the TCP or UDP port on which an application would listen. Note that this is not a list -- if a program listens on multiple ports, or on a combination of TCP and UDP, each will be represented by its own object.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="inetlisteningservers_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The inetlisteningservers_state element defines the different information that can be used to evaluate the specified inet listening server. This includes the local address, foreign address, port information, and process id. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="protocol" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The protocol entity defines the specific transport-layer protocol, in lowercase: tcp or udp, associated with the inet listening server.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="local_address" type="oval-def:EntityStateIPAddressStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the IP address of the network interface on which the program listens. Note that the IP address can be IPv4 or IPv6.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="local_port" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the TCP or UDP port number associated with the inet listening server.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="local_full_address" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the IP address and network port number associated with the inet listening server, equivalent to local_address:local_port. Note that the IP address can be IPv4 or IPv6.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="program_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the name of the communicating program.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="foreign_address" type="oval-def:EntityStateIPAddressStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the IP address with which the program is communicating, or with which it will communicate, in the case of a listening server. Note that the IP address can be IPv4 or IPv6.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="foreign_port" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the TCP or UDP port to which the program communicates. In the case of a listening program accepting new connections, this is usually a *.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="foreign_full_address" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the IP address and network port to which the program is communicating or will accept communications from, equivalent to foreign_address:foreign_port. Note that the IP address can be IPv4 or IPv6.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="pid" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The pid is the process ID of a specific process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="user_id" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The numeric user id, or uid, is the third column of each user's entry in /etc/passwd. It represents the owner, and thus privilege level, of the specified program.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ===============================  PARTITION TEST  ============================== -->
     <!-- =============================================================================== -->
     <xsd:element name="partition_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The partition_test is used to check the information associated with partitions on the local system. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a partition_object and the optional state element references a partition_state that specifies the information to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>partition_test</oval:test>
                         <oval:object>partition_object</oval:object>
                         <oval:state>partition_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">partition_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_partitiontst">
                         <sch:rule context="linux-def:partition_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:partition_object/@id"><sch:value-of select="../@id"/> - the object child element of a partition_test must reference a partition_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:partition_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:partition_state/@id"><sch:value-of select="../@id"/> - the state child element of a partition_test must reference a partition_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="partition_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The partition_object is used by a partition_test to define which partitions on the local system should be collected. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="mount_point" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The mount_point element specifies the mount points of the partitions that should be collected from the local system.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="partition_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The partition_state element defines the different information associated with a partition. This includes the name, filesystem type, mount options, total space, space used, and space left. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="mount_point" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The mount_point element contains a string that represents the mount point of a partition on the local system.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="device" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The device element contains a string that represents the name of the device.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="uuid" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The uuid element contains a string that represents the universally unique identifier associated with a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="fs_type" type="linux-def:EntityStateFileSystemTypeType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The fs_type element contains a string that represents the type of filesystem on a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="mount_options" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The mount_options element contains a string that represents the mount options associated with a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="total_space" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The total_space element contains an integer that represents the total number of blocks on a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="space_used" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The space_used element contains an integer that represents the number of blocks used on a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="space_left" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The space_left element contains an integer that represents the number of blocks left on a partition.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ===============================  RPM INFO TEST  =============================== -->
     <!-- =============================================================================== -->
     <xsd:element name="rpminfo_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The rpm info test is used to check the RPM header information for a given RPM package. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a rpminfo_object and the optional state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>rpminfo_test</oval:test>
                         <oval:object>rpminfo_object</oval:object>
                         <oval:state>rpminfo_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">rpminfo_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_rpminfo_test">
                         <sch:rule context="linux-def:rpminfo_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:rpminfo_object/@id"><sch:value-of select="../@id"/> - the object child element of an rpminfo_test must reference an rpminfo_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:rpminfo_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:rpminfo_state/@id"><sch:value-of select="../@id"/> - the state child element of an rpminfo_test must reference an rpminfo_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="rpminfo_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The rpminfo_object element is used by a rpm info test to define the object to be evaluated. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
               <xsd:documentation>A rpm info object consists of a single name entity that identifies the package being checked.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the package name to check.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="rpminfo_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The rpminfo_state element defines the different information that can be used to evaluate the specified rpm. This includes the architecture, epoch number, and version numbers. Most of this information can be obtained through the rpm function. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the package name to check.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="arch" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the architecture for which the RPM was built, like : i386, ppc, sparc, noarch. In the case of an apache rpm named httpd-2.0.40-21.11.4.i686.rpm, this value would be i686.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="epoch" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the epoch number of the RPM, this is used as a kludge for version-release comparisons where the vendor has done some kind of re-numbering or version forking. For a null epoch (or '(none)' as returned by rpm) the string '(none)' should be used.. This number is not revealed by a normal query of the RPM's information -- you must use a formatted rpm query command to gather this data from the command line, like so. For an already-installed RPM: rpm -q --qf '%{EPOCH}\n' installed_rpm For an RPM file that has not been installed: rpm -qp --qf '%{EPOCH}\n' rpm_file</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="int"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="release" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the release number of the build, changed by the vendor/builder.</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="version"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="version" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the version number of the build. In the case of an apache rpm named httpd-2.0.40-21.11.4.i686.rpm, this value would be 21.11.4.</xsd:documentation>
                                   </xsd:annotation>
                                   <xsd:complexType>
                                        <xsd:simpleContent>
                                             <xsd:restriction base="oval-def:EntityStateAnySimpleType">
                                                  <xsd:attribute name="datatype" use="optional" default="string">
                                                       <xsd:simpleType>
                                                            <xsd:restriction base="oval:SimpleDatatypeEnumeration">
                                                                 <xsd:enumeration value="string"/>
                                                                 <xsd:enumeration value="version"/>
                                                            </xsd:restriction>
                                                       </xsd:simpleType>
                                                  </xsd:attribute>
                                             </xsd:restriction>
                                        </xsd:simpleContent>
                                   </xsd:complexType>
                              </xsd:element>
                              <xsd:element name="evr" type="oval-def:EntityStateEVRStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE". Note that a null epoch (or '(none)' as returned by rpm) is equivalent to '0' and would hence have the form 0:VERSION-RELEASE. Comparisons involving this datatype should follow the algorithm of librpm's rpmvercmp() function.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="signature_keyid" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This field contains the 64-bit PGP key ID that the RPM issuer (generally the original operating system vendor) uses to sign the key. Note that the value should NOT contain a hyphen to seperat the higher 32-bits from the lower 32-bits. It should simply be a 16 character hex string. PGP is used to verify the authenticity and integrity of the RPM being considered. Software packages and patches are signed cryptographically to allow administrators to allay concerns that the distribution mechanism has been compromised, whether that mechanism is web site, FTP server, or even a mirror controlled by a hostile party. OVAL uses this field most of all to confirm that the package installed on the system is that shipped by the vendor, since comparing package version numbers against patch announcements is only programmatically valid if the installed package is known to contain the patched code.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ==============================  RPM VERIFY TEST  ============================== -->
     <!-- =============================================================================== -->
     <xsd:element name="rpmverify_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The rpmverify_test is used to verify the integrity of installed RPMs. This test aligns with the rpm -V command for verifying RPMs. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a rpmverify_object and the optional state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>rpmverify_test</oval:test>
                         <oval:object>rpmverify_object</oval:object>
                         <oval:state>rpmverify_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">rpmverify_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_rpmverify_test">
                         <sch:rule context="linux-def:rpmverify_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:rpmverify_object/@id"><sch:value-of select="../@id"/> - the object child element of an rpmverify_test must reference an rpmverify_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:rpmverify_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:rpmverify_state/@id"><sch:value-of select="../@id"/> - the state child element of an rpmverify_test must reference an rpmverify_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="rpmverify_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The rpmverify_object element is used by a rpmverity_test to define a set of files within a set of RPMs to verify. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="behaviors" type="linux-def:RpmVerifyBehaviors" minOccurs="0" maxOccurs="1"/>
                                        <xsd:element name="name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the package name to check.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element name="filepath" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The filepath element specifies the absolute path for a file in the specified package. A directory cannot be specified as a filepath.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="rpmverify_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The rpmverify_state element defines the different information that can be used to evaluate the specified rpm. This includes the architecture, epoch number, and version numbers. Most of this information can be obtained through the rpm function. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the package name to check.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="filepath" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The filepath element specifies the absolute path for a file in the specified package. A directory cannot be specified as a filepath.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="size_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The size_differs entity aligns with the first character ('S' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="mode_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The mode_differs entity aligns with the second character ('M' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="md5_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The md5_differs entity aligns with the third character ('5' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="device_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The device_differs entity aligns with the fourth character ('D' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="link_mismatch" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The link_mismatch entity aligns with the fifth character ('L' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="ownership_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The ownership_differs entity aligns with the sixth character ('U' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="group_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The group_differs entity aligns with the seventh character ('U' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="mtime_differs" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The mtime_differs entity aligns with the eighth character ('T' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="capabilities_differ" type="linux-def:EntityStateRpmVerifyResultType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The size_differs entity aligns with the ninth character ('P' flag) in the character string in the output generated by running rpm –V on a specific file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="configuration_file" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The configuration_file entity represents the configuration file attribute marker that may be present on a file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="documentation_file" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The documentation_file entity represents the documenation file attribute marker that may be present on a file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="ghost_file" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The ghost_file entity represents the ghost file attribute marker that may be present on a file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="license_file" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The license_file entity represents the license file attribute marker that may be present on a file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="readme_file" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The readme_file entity represents the readme file attribute marker that may be present on a file.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:complexType name="RpmVerifyBehaviors">
          <xsd:annotation>
               <xsd:documentation>The RpmVerifyBehaviors complex type defines a set of behaviors that for controlling how installed rpms are verified. These behaviors align with the verify-options of the rpm command with the addition of two behaviors that will indicate that a file with a given attribute marker should not be collected.</xsd:documentation>
          </xsd:annotation>
          <xsd:attribute name="nodeps" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nodeps' when true this behavior means, don't verify dependencies of packages.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nodigest" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nodigest' when true this behavior means, don't verify package or header digests when reading.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nofiles" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nofiles' when true this behavior means, don't verify any attributes of package files.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="noscripts" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'noscripts' when true this behavior means, don't execute the %verifyscript scriptlet (if any).</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nosignature" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nosignature' when true this behavior means, don't verify package or header signatures when reading.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nolinkto" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nolinkto' when true this behavior means, don't verify symbolic links attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nomd5" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nomd5' when true this behavior means, don't verify the file md5 attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nosize" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nosize' when true this behavior means, don't verify the file size attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nouser" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nouser' when true this behavior means, don't verify the file owner attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nogroup" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nogroup' when true this behavior means, don't verify the file group owner attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nomtime" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nomtime' when true this behavior means, don't verify the file mtime attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nomode" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nomode' when true this behavior means, don't verify the file mode attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="nordev" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'nordev' when true this behavior means, don't verify the file rdev attribute.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="noconfigfiles" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'noconfigfiles' when true this behavior means, skip files that are marked with the %config attribute marker.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="noghostfiles" use="optional" type="xsd:boolean" default="false">
               <xsd:annotation>
                    <xsd:documentation>'noghostfiles' when true this behavior means, skip files that are maked with %ghost attribute marker.</xsd:documentation>
               </xsd:annotation>
          </xsd:attribute>
     </xsd:complexType>
     <!-- =============================================================================== -->
     <!-- ===========================  SELINUX BOOLEAN TEST  =========+================== -->
     <!-- =============================================================================== -->
     <xsd:element name="selinuxboolean_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The selinuxboolean_test is used to check the current and pending status of a SELinux boolean. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a selinuxboolean_object and the optional state element references a selinuxboolean_state that specifies the metadata to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>selinuxboolean_test</oval:test>
                         <oval:object>selinuxboolean_object</oval:object>
                         <oval:state>selinuxboolean_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">selinuxboolean_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_selinuxbooleantst">
                         <sch:rule context="linux-def:selinuxboolean_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:selinuxboolean_object/@id"><sch:value-of select="../@id"/> - the object child element of an selinuxboolean_test must reference an selinuxboolean_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:selinuxboolean_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:selinuxboolean_state/@id"><sch:value-of select="../@id"/> - the state child element of an selinuxboolean_test must reference an selinuxboolean_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType"/>
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="selinuxboolean_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The selinuxboolean_object element is used by an selinuxboolean_test to define the items to evaluate based on a specified state.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The name of the SELinux boolean.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="selinuxboolean_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The selinuxboolean_state element defines the different information that can be used to evaluate the specified SELinux boolean. This includes SELinux boolean's current and pending status. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0">
                                   <xsd:annotation>
                                        <xsd:documentation>The name of the SELinux boolean.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="current_status" type="oval-def:EntityStateBoolType" minOccurs="0">
                                   <xsd:annotation>
                                        <xsd:documentation>The current_status entity represents the current state of the specified SELinux boolean.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="pending_status" type="oval-def:EntityStateBoolType" minOccurs="0">
                                   <xsd:annotation>
                                        <xsd:documentation>The pending_status entity represents the pending state of the specified SELinux boolean.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ======================  SELINUX SECURITY CONTEXT TEST  ======================== -->
     <!-- =============================================================================== -->
     <xsd:element name="selinuxsecuritycontext_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The selinuxsecuritycontext_test is used to check the security context of a file or process on the local system. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a selinuxsecuritycontext_object and the optional state element references a selinuxsecuritycontext_state that specifies the metadata to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>selinuxsecuritycontext_test</oval:test>
                         <oval:object>selinuxsecuritycontext_object</oval:object>
                         <oval:state>selinuxsecuritycontext_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">selinuxsecuritycontext_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_selinuxsecuritycontexttst">
                         <sch:rule context="linux-def:selinuxsecuritycontext_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:selinuxsecuritycontext_object/@id"><sch:value-of select="../@id"/> - the object child element of an selinuxsecuritycontext_test must reference an selinuxsecuritycontext_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:selinuxsecuritycontext_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:selinuxsecuritycontext_state/@id"><sch:value-of select="../@id"/> - the state child element of an selinuxsecuritycontext_test must reference an selinuxsecuritycontext_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType"/>
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="selinuxsecuritycontext_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The selinuxsecuritycontext_object element is used by an selinuxsecuritycontext_test to define the security contexts of files and processes to collect from the local system. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:choice>
                                             <xsd:element name="filepath" type="oval-def:EntityObjectStringType">
                                                  <xsd:annotation>
                                                       <xsd:documentation>The filepath element specifies the absolute path for a file on the machine. A directory cannot be specified as a filepath.</xsd:documentation>
                                                  </xsd:annotation>
                                             </xsd:element>
                                             <xsd:sequence>
                                                  <xsd:element name="path" type="oval-def:EntityObjectStringType">
                                                       <xsd:annotation>
                                                            <xsd:documentation>The path element specifies the directory component of the absolute path to a file on the machine.</xsd:documentation>
                                                       </xsd:annotation>
                                                  </xsd:element>
                                                  <xsd:element name="filename" type="oval-def:EntityObjectStringType"  nillable="true">
                                                       <xsd:annotation>
                                                            <xsd:documentation>The filename element specifies the name of a file to evaluate. If the xsi:nil attribute is set to true, then the object being specified is the higher level directory object (not all the files in the directory).  In this case, the filename element should not be used during collection and would result in the unique set of items being the directories themselves. For example, one would set xsi:nil to true if the desire was to test the attributes or permissions associated with a directory. Setting xsi:nil equal to true is different than using a .* pattern match, which says to collect every file under a given path.</xsd:documentation>
                                                       </xsd:annotation>
                                                  </xsd:element>
                                             </xsd:sequence>
                                             <xsd:element name="pid" type="oval-def:EntityObjectIntType">
                                                  <xsd:annotation>
                                                       <xsd:documentation>The pid entity is the process ID of the process.</xsd:documentation>
                                                  </xsd:annotation>
                                             </xsd:element>
                                        </xsd:choice>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="selinuxsecuritycontext_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The selinuxsecuritycontext_state element defines the different information that can be used to evaluate the specified SELinux security context. This includes SELinux security context's user, type role, low sensitivity, low category, high sensitivity, high category, raw low sensitivity, raw low category, raw high sensitivity, and raw high category. This state follows the SELinux security context structure: user:role:type:low_sensitivity[:low_category]- high_sensitivity [:high_category]. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="filepath" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The filepath element specifies the absolute path for a file on the machine. A directory cannot be specified as a filepath.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="path" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The path element specifies the directory component of the absolute path to a file on the machine.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="filename" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The name of the file. If the xsi:nil attribute is set to true, then the item being represented is the higher directory represented by the path entity.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="pid" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the process ID of the process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="user" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The user element specifies the SELinux user that either created the file or started the process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="role" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The role element specifies the types that a process may transition to (domain transitions). Note that this entity is not relevant for files and will always have a value of object_r.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="type" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The type element specifies the domain in which the file is accessible or the domain in which a process executes.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="low_sensitivity" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The low_sensitivity element specifies the current sensitivity of a file or process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="low_category" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The low_category element specifies the set of categories associated with the low sensitivity.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="high_sensitivity" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The high_sensitivity element specifies the maximum range for a file or the clearance for a process.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="high_category" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The high_category element specifies the set of categories associated with the high sensitivity.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="rawlow_sensitivity" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The rawlow_sensitivity element specifies the current sensitivity of a file or process but in its raw context.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="rawlow_category" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The rawlow_category element specifies the set of categories associated with the low sensitivity but in its raw context.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="rawhigh_sensitivity" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The rawhigh_sensitivity element specifies the maximum range for a file or the clearance for a process but in its raw context.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="rawhigh_category" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The rawhigh_category element specifies the set of categories associated with the high sensitivity but in its raw context.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ==========================  SLACKWARE PKG INFO TEST  ========================== -->
     <!-- =============================================================================== -->
     <xsd:element name="slackwarepkginfo_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>The slackware package info test is used to check information associated with a given Slackware package. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a slackwarepkginfo_object and the optional state element specifies the data to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>slackwarepkginfo_test</oval:test>
                         <oval:object>slackwarepkginfo_object</oval:object>
                         <oval:state>slackwarepkginfo_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">slackwarepkginfo_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_slackwarepkginfo_test">
                         <sch:rule context="linux-def:slackwarepkginfo_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:slackwarepkginfo_object/@id"><sch:value-of select="../@id"/> - the object child element of an slackwarepkginfo_test must reference an slackwarepkginfo_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:slackwarepkginfo_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:slackwarepkginfo_state/@id"><sch:value-of select="../@id"/> - the state child element of an slackwarepkginfo_test must reference an slackwarepkginfo_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="slackwarepkginfo_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>The slackwarepkginfo_object element is used by a slackware package info test to define the object to be evaluated. Each object extends the standard ObjectType as defined in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
               <xsd:documentation>A slackware package info object consists of a single name entity that identifies the package being checked.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the package name to check.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="slackwarepkginfo_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The slackwarepkginfo_state element defines the different information that can be used to evaluate the specified package. This includes the version, architecture, and revision. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the package name to check.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="version" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>This is the version number of the package.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="architecture" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation/>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="revision" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation/>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- =============================================================================== -->
     <!-- =============================================================================== -->
     <xsd:complexType name="EntityStateFileSystemTypeType">
          <xsd:annotation>
               <xsd:documentation>The EntityStateFileSystemTypeType complex type restricts a string value to the set of values that are used to describe file systems on a Linux system. This list is based off of the values defined in linux/magic.h. Please consult linux/magic.h for additional information on each allowed value. The empty string is also allowed to support the empty element associated with variable references.  Note that when using pattern matches and variables care must be taken to ensure that the regular expression and variable values align with the enumerated values.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:restriction base="oval-def:EntityStateStringType">
                    <xsd:enumeration value="ADFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="AFFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="AFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="AUTOFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="CODA_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="CRAMFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="CRAMFS_MAGIC_WEND">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="DEBUGFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SYSFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SECURITYFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SELINUX_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="RAMFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="TMPFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="HUGETLBFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SQUASHFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="EFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="EXT2_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="EXT3_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="XENFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="EXT4_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="BTRFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="HPFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ISOFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="JFFS2_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ANON_INODE_FS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MINIX_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MINIX_SUPER_MAGIC2">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MINIX2_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MINIX2_SUPER_MAGIC2">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MINIX3_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="MSDOS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="NCP_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="NFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="OPENPROM_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="PROC_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="QNX4_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="REISERFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="REISERFS_SUPER_MAGIC_STRING">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="REISER2FS_SUPER_MAGIC_STRING">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="REISER2FS_JR_SUPER_MAGIC_STRING">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SMB_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="USBDEVICE_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="CGROUP_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="FUTEXFS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="STACK_END_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="DEVPTS_SUPER_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="SOCKFS_MAGIC">
                         <xsd:annotation>
                              <xsd:documentation/>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="">
                         <xsd:annotation>
                              <xsd:documentation>The empty string value is permitted here to allow for empty elements associated with variable references.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
               </xsd:restriction>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="EntityStateSeLinuxModeType">
          <xsd:annotation>
               <xsd:documentation>The EntityStateSeLinuxModeType complex type restricts a string value to three values: 1)enforcing 2)permissive or 3)disabled. These values indicate the current mode of SELinux on a system. The empty string is also allowed to support the empty element associated with variable references.  Note that when using pattern matches and variables care must be taken to ensure that the regular expression and variable values align with the enumerated values.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:restriction base="oval-def:EntityStateStringType">
                    <xsd:enumeration value="enforcing">
                         <xsd:annotation>
                              <xsd:documentation>A value of 'enforcing' indicates that the SELinux security policy is enforced and will deny access based on the security policy rules.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="permissive">
                         <xsd:annotation>
                              <xsd:documentation>A value of 'permissive' indicates that the SELinux security policy is not enforced and will not deny access, but, it will still log denial messages.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="disabled">
                         <xsd:annotation>
                              <xsd:documentation>A value of 'disabled' indicates that SELinux is disabled.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="">
                         <xsd:annotation>
                              <xsd:documentation>The empty string value is permitted here to allow for empty elements associated with variable references.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
               </xsd:restriction>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="EntityStateRpmVerifyResultType">
          <xsd:annotation>
               <xsd:documentation>The EntityStateRpmVerifyResultType complex type restricts a string value to the set of possible outcomes of checking an attribute of a file included in an RPM against the actual value of that attribute in the RPM database. The empty string is also allowed to support the empty element associated with variable references.  Note that when using pattern matches and variables care must be taken to ensure that the regular expression and variable values align with the enumerated values.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:restriction base="oval-def:EntityStateStringType">
                    <xsd:enumeration value="pass">
                         <xsd:annotation>
                              <xsd:documentation>'pass' indicates that the test passed and is equivalent to the '.' value reported by the rpm -V command.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="fail">
                         <xsd:annotation>
                              <xsd:documentation>'fail' indicates that the test failed and is equivalent to a bold charcter in the test result string reported by the rpm -V command.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="not performed">
                         <xsd:annotation>
                              <xsd:documentation>'not performed' indicates that the test could not be performed and is equivalent to the '?' value reported by the rpm -V command.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="">
                         <xsd:annotation>
                              <xsd:documentation>The empty string value is permitted here to allow for empty elements associated with variable references.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
               </xsd:restriction>
          </xsd:simpleContent>
     </xsd:complexType>
     <xsd:complexType name="EntityStateProtocolType">
          <xsd:annotation>
               <xsd:documentation>The EntityStateProtocolType complex type restricts a string value to the set of physical layer protocols used by AF_PACKET sockets. The empty string is also allowed to support the empty element associated with variable references.  Note that when using pattern matches and variables care must be taken to ensure that the regular expression and variable values align with the enumerated values.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleContent>
               <xsd:restriction base="oval-def:EntityStateStringType">
                    <xsd:enumeration value="ETH_P_LOOP">
                         <xsd:annotation>
                              <xsd:documentation>Ethernet loopback packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PUP">
                         <xsd:annotation>
                              <xsd:documentation>Xerox PUP packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PUPAT">
                         <xsd:annotation>
                              <xsd:documentation>Xerox PUP Address Transport packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IP">
                         <xsd:annotation>
                              <xsd:documentation>Internet protocol packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_X25">
                         <xsd:annotation>
                              <xsd:documentation>CCITT X.25 packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ARP">
                         <xsd:annotation>
                              <xsd:documentation>Address resolution packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_BPQ">
                         <xsd:annotation>
                              <xsd:documentation>G8BPQ AX.25 ethernet packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IEEEPUP">
                         <xsd:annotation>
                              <xsd:documentation>Xerox IEEE802.3 PUP packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IEEEPUPAT">
                         <xsd:annotation>
                              <xsd:documentation>Xerox IEEE802.3 PUP address transport packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DEC">
                         <xsd:annotation>
                              <xsd:documentation>DEC assigned protocol.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DNA_DL">
                         <xsd:annotation>
                              <xsd:documentation>DEC DNA Dump/Load.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DNA_RC">
                         <xsd:annotation>
                              <xsd:documentation>DEC DNA Remote Console.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DNA_RT">
                         <xsd:annotation>
                              <xsd:documentation>DEC DNA Routing.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_LAT">
                         <xsd:annotation>
                              <xsd:documentation>DEC LAT.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DIAG">
                         <xsd:annotation>
                              <xsd:documentation>DEC Diagnostics.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_CUST">
                         <xsd:annotation>
                              <xsd:documentation>DEC Customer use.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_SCA">
                         <xsd:annotation>
                              <xsd:documentation>DEC Systems Comms Arch.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_RARP">
                         <xsd:annotation>
                              <xsd:documentation>Reverse address resolution packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ATALK">
                         <xsd:annotation>
                              <xsd:documentation>Appletalk DDP.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_AARP">
                         <xsd:annotation>
                              <xsd:documentation>Appletalk AARP.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_8021Q">
                         <xsd:annotation>
                              <xsd:documentation>802.1Q VLAN Extended Header.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IPX">
                         <xsd:annotation>
                              <xsd:documentation>IPX over DIX.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IPV6">
                         <xsd:annotation>
                              <xsd:documentation>IPv6 over bluebook.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_SLOW">
                         <xsd:annotation>
                              <xsd:documentation>Slow Protocol. See 802.3ad 43B.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_WCCP">
                         <xsd:annotation>
                              <xsd:documentation>Web-cache coordination protocol.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PPP_DISC">
                         <xsd:annotation>
                              <xsd:documentation>PPPoE discovery messages.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PPP_SES">
                         <xsd:annotation>
                              <xsd:documentation>PPPoE session messages.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_MPLS_UC">
                         <xsd:annotation>
                              <xsd:documentation>MPLS Unicast traffic.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_MPLS_MC">
                         <xsd:annotation>
                              <xsd:documentation>MPLS Multicast traffic.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ATMMPOA">
                         <xsd:annotation>
                              <xsd:documentation>MultiProtocol Over ATM.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ATMFATE">
                         <xsd:annotation>
                              <xsd:documentation>Frame-based ATM Transport over Ethernet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_AOE">
                         <xsd:annotation>
                              <xsd:documentation>ATA over Ethernet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_TIPC">
                         <xsd:annotation>
                              <xsd:documentation>TIPC.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_802_3">
                         <xsd:annotation>
                              <xsd:documentation>Dummy type for 802.3 frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_AX25">
                         <xsd:annotation>
                              <xsd:documentation>Dummy protocol id for AX.25.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ALL">
                         <xsd:annotation>
                              <xsd:documentation>Every packet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_802_2">
                         <xsd:annotation>
                              <xsd:documentation>802.2 frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_SNAP">
                         <xsd:annotation>
                              <xsd:documentation>Internal only.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_DDCMP">
                         <xsd:annotation>
                              <xsd:documentation>DEC DDCMP: Internal only</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_WAN_PPP">
                         <xsd:annotation>
                              <xsd:documentation>Dummy type for WAN PPP frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PPP_MP">
                         <xsd:annotation>
                              <xsd:documentation>Dummy type for PPP MP frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_PPPTALK">
                         <xsd:annotation>
                              <xsd:documentation>Dummy type for Atalk over PPP.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_LOCALTALK">
                         <xsd:annotation>
                              <xsd:documentation>Localtalk pseudo type.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_TR_802_2">
                         <xsd:annotation>
                              <xsd:documentation>802.2 frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_MOBITEX">
                         <xsd:annotation>
                              <xsd:documentation>Mobitex.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_CONTROL">
                         <xsd:annotation>
                              <xsd:documentation>Card specific control frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_IRDA">
                         <xsd:annotation>
                              <xsd:documentation>Linux-IrDA.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ECONET">
                         <xsd:annotation>
                              <xsd:documentation>Acorn Econet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_HDLC">
                         <xsd:annotation>
                              <xsd:documentation>HDLC frames.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="ETH_P_ARCNET">
                         <xsd:annotation>
                              <xsd:documentation>1A for ArcNet.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="">
                         <xsd:annotation>
                              <xsd:documentation>The empty string value is permitted here to allow for empty elements associated with variable references.</xsd:documentation>
                         </xsd:annotation>
                    </xsd:enumeration>
               </xsd:restriction>
          </xsd:simpleContent>
     </xsd:complexType>
</xsd:schema>
