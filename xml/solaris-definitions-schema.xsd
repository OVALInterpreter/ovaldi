<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:sol-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris" xmlns:sch="http://purl.oclc.org/dsdl/schematron" targetNamespace="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris" elementFormDefault="qualified" version="5.4">
      <xsd:import namespace="http://oval.mitre.org/XMLSchema/oval-definitions-5" schemaLocation="oval-definitions-schema.xsd"/>
      <xsd:annotation>
            <xsd:documentation>The following is a description of the elements, types, and attributes that compose the Solaris specific tests found in Open Vulnerability and Assessment Language (OVAL). Each test is an extension of the standard test element defined in the Core Definition Schema. Through extension, each test inherits a set of elements and attributes that are shared amongst all OVAL tests. Each test is described in detail and should provide the information necessary to understand what each element and attribute represents. This document is intended for developers and assumes some familiarity with XML. A high level description of the interaction between the different tests and their relationship to the Core Definition Schema is not outlined here.</xsd:documentation>
            <xsd:documentation>The OVAL Schema is maintained by The Mitre Corporation and developed by the public OVAL Community. For more information, including how to get involved in the project and how to submit change requests, please visit the OVAL website at http://oval.mitre.org.</xsd:documentation>
            <xsd:appinfo>
                  <schema>Solaris Definition</schema>
                  <version>5.4</version>
                  <date>4/1/2008 10:41:45 AM</date>
                  <terms_of_use>Copyright (c) 2002-2008, The MITRE Corporation. All rights reserved.  The contents of this file are subject to the terms of the OVAL License located at http://oval.mitre.org/oval/about/termsofuse.html. See the OVAL License for the specific language governing permissions and limitations for use of this schema.  When distributing copies of the OVAL Schema, this license header must be included.</terms_of_use>
                  <sch:title>schematron validation of the Solaris portion of an OVAL Definitions file</sch:title>
                  <sch:ns prefix="oval-def" uri="http://oval.mitre.org/XMLSchema/oval-definitions-5"/>
                  <sch:ns prefix="sol-def" uri="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"/>
                  <sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/>
            </xsd:appinfo>
      </xsd:annotation>
      <!-- =============================================================================== -->
      <!-- ===============================  ISAINFO TEST  ================================ -->
      <!-- =============================================================================== -->
      <xsd:element name="isainfo_test" substitutionGroup="oval-def:test">
            <xsd:annotation>
                  <xsd:documentation>The isainfo test reveals information about the instruction set architectures. This information can be retrieved by the isainfo command. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an isainfo_object and the optional state element specifies the metadata to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
                  <xsd:documentation>The isainfo_test was originally developed by Robert L. Hollis at ThreatGuard, Inc. Many thanks for their support of the OVAL project.</xsd:documentation>
                  <xsd:appinfo>
                        <sch:pattern id="isainfotst">
                              <sch:rule context="sol-def:isainfo_test/sol-def:object">
                                    <sch:assert test="@object_ref=/oval-def:oval_definitions/oval-def:objects/sol-def:smf_object/@id">
                                          <sch:value-of select="../@id"/> - the object child element of an isainfo_test must reference an isainfo_object</sch:assert>
                              </sch:rule>
                              <sch:rule context="sol-def:isainfo_test/sol-def:state">
                                    <sch:assert test="@state_ref=/oval-def:oval_definitions/oval-def:states/sol-def:smf_state/@id">
                                          <sch:value-of select="../@id"/> - the state child element of an isainfo_test must reference an isainfo_state</sch:assert>
                              </sch:rule>
                        </sch:pattern>
                  </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:TestType">
                              <xsd:sequence>
                                    <xsd:element name="object" type="oval-def:ObjectRefType" minOccurs="1" maxOccurs="1"/>
                                    <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="isainfo_object" substitutionGroup="oval-def:object">
            <xsd:annotation>
                  <xsd:documentation>The isainfo_object element is used by an isainfo test to define those objects to evaluated based on a specified state. There is actually only one object relating to isainfo and this is the system as a whole. Therefore, there are no child entities defined. Any OVAL Test written to check isainfo will reference the same isainfo_object which is basically an empty object element.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:ObjectType"/>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="isainfo_state" substitutionGroup="oval-def:state">
            <xsd:annotation>
                  <xsd:documentation>The isainfo_state element defines the information about the instruction set architectures. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:StateType">
                              <xsd:sequence>
                                    <xsd:element name="bits" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>This is the number of bits in the address space of the native instruction set (isainfo -b).</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="isastebits">
                                                            <sch:rule context="sol-def:isainfo_state/sol-def:bits">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the bits entity of an isainfo_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="kernel_isa" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>This is the name of the instruction set used by kernel components (isainfo -k).</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="isastekernel_isa">
                                                            <sch:rule context="sol-def:isainfo_state/sol-def:kernel_isa">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the kernel_isa entity of an isainfo_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="application_isa" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>This is the name of the instruction set used by portable applications (isainfo -n).</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="isasteapplication_isa">
                                                            <sch:rule context="sol-def:isainfo_state/sol-def:application_isa">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the application_isa entity of an isainfo_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <!-- =============================================================================== -->
      <!-- ===============================  PACKAGE TEST  ================================ -->
      <!-- =============================================================================== -->
      <xsd:element name="package_test" substitutionGroup="oval-def:test">
            <xsd:annotation>
                  <xsd:documentation>The package test is used to check information associated with different packages installed on the system. The information used by this test is modeled after the /usr/bin/pkginfo command. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an inetd_object and the optional state element specifies the information to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
                  <xsd:appinfo>
                        <sch:pattern id="packagetst">
                              <sch:rule context="sol-def:package_test/sol-def:object">
                                    <sch:assert test="@object_ref=/oval-def:oval_definitions/oval-def:objects/sol-def:package_object/@id">
                                          <sch:value-of select="../@id"/> - the object child element of a package_test must reference a package_object</sch:assert>
                              </sch:rule>
                              <sch:rule context="sol-def:package_test/sol-def:state">
                                    <sch:assert test="@state_ref=/oval-def:oval_definitions/oval-def:states/sol-def:package_state/@id">
                                          <sch:value-of select="../@id"/> - the state child element of a package_test must reference a package_state</sch:assert>
                              </sch:rule>
                        </sch:pattern>
                  </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:TestType">
                              <xsd:sequence>
                                    <xsd:element name="object" type="oval-def:ObjectRefType" minOccurs="1" maxOccurs="1"/>
                                    <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="package_object" substitutionGroup="oval-def:object">
            <xsd:annotation>
                  <xsd:documentation>The package_object element is used by a package test to define the packages to be evaluated. Each object extends the standard ObjectType as definied in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
                  <xsd:documentation>A package object consists of a single pkginst entity that identifies the package to be used.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:ObjectType">
                              <xsd:sequence>
                                    <xsd:choice minOccurs="1" maxOccurs="1">
                                          <xsd:element ref="oval-def:set"/>
                                          <xsd:sequence>
                                                <xsd:element name="pkginst" type="oval-def:EntityObjectStringType" minOccurs="1" maxOccurs="1">
                                                      <xsd:annotation>
                                                            <xsd:documentation>The pkginst entity is a string that represents a package designation by its instance. An instance can be the package abbreviation or a specific instance (for example, inst.1 or inst.2).</xsd:documentation>
                                                            <xsd:appinfo>
                                                                  <sch:pattern id="packageobjpkginst">
                                                                        <sch:rule context="sol-def:package_object/sol-def:pkginst">
                                                                              <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the pkginst entity of a package_object should be 'string'</sch:assert>
                                                                        </sch:rule>
                                                                  </sch:pattern>
                                                            </xsd:appinfo>
                                                      </xsd:annotation>
                                                </xsd:element>
                                          </xsd:sequence>
                                    </xsd:choice>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="package_state" substitutionGroup="oval-def:state">
            <xsd:annotation>
                  <xsd:documentation>The package_state element defines the different information associated with packages installed on the system. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:StateType">
                              <xsd:sequence>
                                    <xsd:element name="pkginst" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The pkginst entity is a string that represents a package designation by its instance. An instance can be the package abbreviation or a specific instance (for example, inst.1 or inst.2).</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagestepkginst">
                                                            <sch:rule context="sol-def:package_state/sol-def:pkginst">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the pkginst entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The name entity is a text string that specifies a full package name.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagestename">
                                                            <sch:rule context="sol-def:package_state/sol-def:name">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the name entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="category" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The category entity is a string in the form of a comma-separated list of categories under which a package may be displayed. Note that a package must at least belong to the system or application category. Categories are case-insensitive and may contain only alphanumerics. Each category is limited in length to 16 characters.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagestecategory">
                                                            <sch:rule context="sol-def:package_state/sol-def:category">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the category entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="version" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The version entity is a text string that specifies the current version associated with the software package. The maximum length is 256 ASCII characters and the first character cannot be a left parenthesis. Current Solaris software practice is to assign this parameter monotonically increasing Dewey decimal values of the form: major_revision.minor_revision[.micro_revision] where all the revision fields are integers. The versioning fields can be extended to an arbitrary string of numbers in Dewey-decimal format, if necessary.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagesteversion">
                                                            <sch:rule context="sol-def:package_state/sol-def:version">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the version entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="vendor" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The vendor entity is a string used to identify the vendor that holds the software copyright (maximum length of 256 ASCII characters).</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagestevendor">
                                                            <sch:rule context="sol-def:package_state/sol-def:vendor">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the vendor entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="description" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The description entity is a string that represents a more in-depth description of a package.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="packagestedescription">
                                                            <sch:rule context="sol-def:package_state/sol-def:description">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the description entity of a package_state should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <!-- =============================================================================== -->
      <!-- ================================  PATCH TEST  ================================= -->
      <!-- =============================================================================== -->
      <xsd:element name="patch54_test" substitutionGroup="oval-def:test">
            <xsd:annotation>
                  <xsd:documentation>The patch test is used to check information associated with different patches installed on the system. The information being tested is based off the /usr/bin/showrev -p command. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an inetd_object and the optional state element specifies the information to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
                  <xsd:appinfo>
                        <sch:pattern id="patch54tst">
                              <sch:rule context="sol-def:patch54_test/sol-def:object">
                                    <sch:assert test="@object_ref=/oval-def:oval_definitions/oval-def:objects/sol-def:patch54_object/@id">
                                          <sch:value-of select="../@id"/> - the object child element of a patch54_test must reference a patch54_object</sch:assert>
                              </sch:rule>
                              <sch:rule context="sol-def:patch54_test/sol-def:state">
                                    <sch:assert test="@state_ref=/oval-def:oval_definitions/oval-def:states/sol-def:patch_state/@id">
                                          <sch:value-of select="../@id"/> - the state child element of a patch54_test must reference a patch_state</sch:assert>
                              </sch:rule>
                        </sch:pattern>
                  </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:TestType">
                              <xsd:sequence>
                                    <xsd:element name="object" type="oval-def:ObjectRefType" minOccurs="1" maxOccurs="1"/>
                                    <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="patch_test" substitutionGroup="oval-def:test">
            <xsd:annotation>
                  <xsd:documentation>This test has been deprecated and will be removed in version 6.0 of the language. Recommend use of the newer patch54_test.</xsd:documentation>
                  <xsd:documentation>The patch test is used to check information associated with different patches installed on the system. The information being tested is based off the /usr/bin/showrev -p command. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references an inetd_object and the optional state element specifies the information to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
                  <xsd:appinfo>
                        <sch:pattern id="patchtst">
                              <sch:rule context="sol-def:patch_test/sol-def:object">
                                    <sch:assert test="@object_ref=/oval-def:oval_definitions/oval-def:objects/sol-def:patch_object/@id">
                                          <sch:value-of select="../@id"/> - the object child element of a patch_test must reference a patch_object</sch:assert>
                              </sch:rule>
                              <sch:rule context="sol-def:patch_test/sol-def:state">
                                    <sch:assert test="@state_ref=/oval-def:oval_definitions/oval-def:states/sol-def:patch_state/@id">
                                          <sch:value-of select="../@id"/> - the state child element of a patch_test must reference a patch_state</sch:assert>
                              </sch:rule>
                        </sch:pattern>
                  </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:TestType">
                              <xsd:sequence>
                                    <xsd:element name="object" type="oval-def:ObjectRefType" minOccurs="1" maxOccurs="1"/>
                                    <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="patch54_object" substitutionGroup="oval-def:object">
            <xsd:annotation>
                  <xsd:documentation>The patch54_object element is used by a patch test to define the specific patch to be evaluated. Each object extends the standard ObjectType as definied in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
                  <xsd:documentation>A patch object consists of a base entity that identifies the patch to be used, and a version entity that represent the patch revision number.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:ObjectType">
                              <xsd:sequence>
                                    <xsd:choice minOccurs="1" maxOccurs="1">
                                          <xsd:element ref="oval-def:set"/>
                                          <xsd:sequence>
                                                <xsd:element name="behaviors" type="sol-def:PatchBehaviors" minOccurs="0" maxOccurs="1"/>
                                                <xsd:element name="base" type="oval-def:EntityObjectIntType" minOccurs="1" maxOccurs="1">
                                                      <xsd:annotation>
                                                            <xsd:documentation>Patches are identified by unique alphanumeric strings, with the patch base code first, a hyphen, and a number that represents the patch revision number.</xsd:documentation>
                                                            <xsd:appinfo>
                                                                  <sch:pattern id="patch54objbase">
                                                                        <sch:rule context="sol-def:patch54_object/sol-def:base">
                                                                              <sch:assert test="@datatype='int'"><sch:value-of select="../@id"/> - datatype attribute for the base entity of a patch54_object should be 'int'</sch:assert>
                                                                        </sch:rule>
                                                                  </sch:pattern>
                                                            </xsd:appinfo>
                                                      </xsd:annotation>
                                                </xsd:element>
                                                <xsd:element name="version" type="oval-def:EntityObjectIntType" minOccurs="1" maxOccurs="1">
                                                      <xsd:annotation>
                                                            <xsd:documentation>Patches are identified by unique alphanumeric strings, with the patch base code first, a hyphen, and a number that represents the patch revision number.</xsd:documentation>
                                                            <xsd:appinfo>
                                                                  <sch:pattern id="patch54objversion">
                                                                        <sch:rule context="sol-def:patch54_object/sol-def:version">
                                                                              <sch:assert test="@datatype='int'"><sch:value-of select="../@id"/> - datatype attribute for the version entity of a patch54_object should be 'int'</sch:assert>
                                                                        </sch:rule>
                                                                  </sch:pattern>
                                                            </xsd:appinfo>
                                                      </xsd:annotation>
                                                </xsd:element>
                                          </xsd:sequence>
                                    </xsd:choice>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="patch_object" substitutionGroup="oval-def:object">
            <xsd:annotation>
                  <xsd:documentation>This object has been deprecated and will be removed in version 6.0 of the language. Recommend use of the newer patch54_object.</xsd:documentation>
                  <xsd:documentation>The patch_object element is used by a patch test to define the specific patch to be evaluated. Each object extends the standard ObjectType as definied in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
                  <xsd:documentation>A patch object consists of a single base entity that identifies the patch to be used.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:ObjectType">
                              <xsd:sequence>
                                    <xsd:choice minOccurs="1" maxOccurs="1">
                                          <xsd:element ref="oval-def:set"/>
                                          <xsd:sequence>
                                                <xsd:element name="base" type="oval-def:EntityObjectIntType" minOccurs="1" maxOccurs="1">
                                                      <xsd:annotation>
                                                            <xsd:documentation>Patches are identified by unique alphanumeric strings, with the patch base code first, a hyphen, and a number that represents the patch revision number.</xsd:documentation>
                                                            <xsd:appinfo>
                                                                  <sch:pattern id="patchobjbase">
                                                                        <sch:rule context="sol-def:patch_object/sol-def:base">
                                                                              <sch:assert test="@datatype='int'"><sch:value-of select="../@id"/> - datatype attribute for the base entity of a patch_object should be 'int'</sch:assert>
                                                                        </sch:rule>
                                                                  </sch:pattern>
                                                            </xsd:appinfo>
                                                      </xsd:annotation>
                                                </xsd:element>
                                          </xsd:sequence>
                                    </xsd:choice>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="patch_state" substitutionGroup="oval-def:state">
            <xsd:annotation>
                  <xsd:documentation>The patch_state element defines the different information associated with a specific patch installed on the system. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:StateType">
                              <xsd:sequence>
                                    <xsd:element name="base" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The base entity reresents a patch base code found before the hyphen.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="patchstebase">
                                                            <sch:rule context="sol-def:patch_state/sol-def:base">
                                                                  <sch:assert test="@datatype='int'"><sch:value-of select="../@id"/> - datatype attribute for the base entity of a patch_state should be 'int'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="version" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The version entity represents a patch version number found after the hyphen</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="patchsteversion">
                                                            <sch:rule context="sol-def:patch_state/sol-def:version">
                                                                  <sch:assert test="@datatype='int'"><sch:value-of select="../@id"/> - datatype attribute for the version entity of a patch_state should be 'int'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:complexType name="PatchBehaviors">
            <xsd:annotation>
                  <xsd:documentation>These behaviors allow a more detailed definition of the patch_object being specified.</xsd:documentation>
            </xsd:annotation>
            <xsd:attribute name="supersedence" use="optional" default="false">
                  <xsd:annotation>
                        <xsd:documentation>'supersedence' specifies that the object should also match any superseding patches to the one being specified. In other words, if set to True the resulting object set would be the original patch specified plus any superseding patches. The default value is 'false' meaning the object should only match the specified patch.</xsd:documentation>
                  </xsd:annotation>
                  <xsd:simpleType>
                        <xsd:restriction base="xsd:boolean"/>
                  </xsd:simpleType>
            </xsd:attribute>
      </xsd:complexType>
      <!-- =============================================================================== -->
      <!-- =================================  SMF TEST  ================================== -->
      <!-- =============================================================================== -->
      <xsd:element name="smf_test" substitutionGroup="oval-def:test">
            <xsd:annotation>
                  <xsd:documentation>The smf_test is used to check service management facility controlled services including traditional unix rc level start/kill scrips and inetd daemon services. It extends the standard TestType as defined in the oval-definitions-schema and one should refer to the TestType description for more information. The required object element references a smf_object and the optional state element specifies the information to check. The evaluation of the test is guided by the check attribute that is inherited from the TestType.</xsd:documentation>
                  <xsd:appinfo>
                        <sch:pattern id="smftst">
                              <sch:rule context="sol-def:smf_test/sol-def:object">
                                    <sch:assert test="@object_ref=/oval-def:oval_definitions/oval-def:objects/sol-def:smf_object/@id">
                                          <sch:value-of select="../@id"/> - the object child element of a smf_test must reference a smf_object</sch:assert>
                              </sch:rule>
                              <sch:rule context="sol-def:smf_test/sol-def:state">
                                    <sch:assert test="@state_ref=/oval-def:oval_definitions/oval-def:states/sol-def:smf_state/@id">
                                          <sch:value-of select="../@id"/> - the state child element of a smf_test must reference a smf_state</sch:assert>
                              </sch:rule>
                        </sch:pattern>
                  </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:TestType">
                              <xsd:sequence>
                                    <xsd:element name="object" type="oval-def:ObjectRefType" minOccurs="1" maxOccurs="1"/>
                                    <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="smf_object" substitutionGroup="oval-def:object">
            <xsd:annotation>
                  <xsd:documentation>The smf_object element is used by a smf_test to define the specific service instance to be evaluated. Each object extends the standard ObjectType as definied in the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.</xsd:documentation>
                  <xsd:documentation>A smf_object consists of a service_name entity that identifies the service and a fmri entity that represents the fault management resource identifier.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:ObjectType">
                              <xsd:sequence>
                                    <xsd:choice minOccurs="1" maxOccurs="1">
                                          <xsd:element ref="oval-def:set"/>
                                          <xsd:sequence>
                                                <xsd:element name="fmri" type="oval-def:EntityObjectStringType" minOccurs="1" maxOccurs="1">
                                                      <xsd:annotation>
                                                            <xsd:documentation>The FMRI (Fault Managed Resource Identifier) entity is used to identify system objects for which advanced fault and resource management capabilities are provided. Services managed by SMF are assigned FMRI URIs prefixed with the scheme name "svc". FMRIs used by SMF can be expressed in three ways: first as an absolute path including a location path such as "localhost" (eg svc://localhost/system/system-log:default), second as a path relative to the local machine (eg svc:/system/system-log:default), and third as simply the service identifier with the string prefixes implied (eg system/system-log:default). For OVAL, the absolute path version (first choice) should be used.</xsd:documentation>
                                                            <xsd:appinfo>
                                                                  <sch:pattern id="fmriobjbase">
                                                                        <sch:rule context="sol-def:smf_object/sol-def:fmri">
                                                                              <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the fmri entity of a smf_object should be 'string'</sch:assert>
                                                                        </sch:rule>
                                                                  </sch:pattern>
                                                            </xsd:appinfo>
                                                      </xsd:annotation>
                                                </xsd:element>
                                          </xsd:sequence>
                                    </xsd:choice>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <xsd:element name="smf_state" substitutionGroup="oval-def:state">
            <xsd:annotation>
                  <xsd:documentation>The smf_state element defines the different information associated with a specific smf controlled service. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
                  <xsd:complexContent>
                        <xsd:extension base="oval-def:StateType">
                              <xsd:sequence>
                                    <xsd:element name="fmri" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The FMRI (Fault Managed Resource Identifier) entity describes a possible identifier associated with a service. Services managed by SMF are assigned FMRI URIs prefixed with the scheme name "svc". FMRIs used by SMF can be expressed in three ways: first as an absolute path including a location path such as "localhost" (eg svc://localhost/system/system-log:default), second as a path relative to the local machine (eg svc:/system/system-log:default), and third as simply the service identifier with the string prefixes implied (eg system/system-log:default). For OVAL, the absolute path version (first choice) should be used.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="fmristebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:fmri">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the fmri entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="service_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The service_name entity is usually an abbreviated form of the FMRI. In the example svc://localhost/system/system-log:default, the name would be system-log.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="srvnamestebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:service_name">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the service_name entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="service_state" type="sol-def:EntityStateSmfServiceStateType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The service_state entity describes a possible state that the service may be in. Each service instance is always in a well-defined state based on its dependencies, the results of the execution of its methods, and its potential receipt of events from the contracts filesystem. The service_state values are UNINITIALIZED, OFFLINE, ONLINE, DEGRADED, MAINTENANCE, DISABLED, and LEGACY-RUN.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="srvstatestebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:service_state">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the service_state entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="protocol" type="sol-def:EntityStateSmfProtocolType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The protocol entity describes a possible protocol supported by the service. Possible values are tcp, tcp6, tcp6only, udp, udp6, and udp6only</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="protocolstebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:protocol">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the protocol entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="server_executable" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The entity server_executable is a string representing the listening daemon on the server side. An example being 'svcprop ftp' which might show 'inetd/start/exec astring /usr/sbin/in.ftpd\ -a'</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="srvexestebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:server_executable">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the server_executable entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="server_arguements" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The server_arguments entity describes possible parameters that are passed to the service.</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="srvargsstebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:server_arguements">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the server_arguements entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                                    <xsd:element name="exec_as_user" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                          <xsd:annotation>
                                                <xsd:documentation>The exec_as_user entity is a string pulled from svcprop in the following format: inetd_start/user astring root</xsd:documentation>
                                                <xsd:appinfo>
                                                      <sch:pattern id="execasuserstebase">
                                                            <sch:rule context="sol-def:smf_state/sol-def:exec_as_user">
                                                                  <sch:assert test="not(@datatype) or @datatype='string'"><sch:value-of select="../@id"/> - datatype attribute for the exec_as_user entity of a smf_object should be 'string'</sch:assert>
                                                            </sch:rule>
                                                      </sch:pattern>
                                                </xsd:appinfo>
                                          </xsd:annotation>
                                    </xsd:element>
                              </xsd:sequence>
                        </xsd:extension>
                  </xsd:complexContent>
            </xsd:complexType>
      </xsd:element>
      <!-- =============================================================================== -->
      <!-- =============================================================================== -->
      <!-- =============================================================================== -->
      <xsd:complexType name="EntityStateSmfProtocolType">
            <xsd:annotation>
                  <xsd:documentation>The EntityStateSmfProtocolType complex type defines the different values that are valid for the protocol entity of a smf_state. The empty string is also allowed as a valid value to support an empty element that is found when a variable reference is used within the type entity.</xsd:documentation>
            </xsd:annotation>
            <xsd:simpleContent>
                  <xsd:restriction base="oval-def:EntityStateStringType">
                        <xsd:enumeration value="tcp">
                              <xsd:annotation>
                                    <xsd:documentation/>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="tcp6">
                              <xsd:annotation>
                                    <xsd:documentation/>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="tcp6only">
                              <xsd:annotation>
                                    <xsd:documentation>Request that service listen only for and pass on true IPv6 requests (not IPv4 mapped ones).</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="udp">
                              <xsd:annotation>
                                    <xsd:documentation/>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="udp6">
                              <xsd:annotation>
                                    <xsd:documentation/>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="udp6only">
                              <xsd:annotation>
                                    <xsd:documentation>Request that service listen only for and pass on true IPv6 requests (not IPv4 mapped ones).</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value=""/>
                  </xsd:restriction>
            </xsd:simpleContent>
      </xsd:complexType>
      <xsd:complexType name="EntityStateSmfServiceStateType">
            <xsd:annotation>
                  <xsd:documentation>The EntityStateSmfServiceStateType complex type defines the different values that are valid for the service_state entity of a smf_state. The empty string is also allowed as a valid value to support an empty element that is found when a variable reference is used within the type entity.</xsd:documentation>
            </xsd:annotation>
            <xsd:simpleContent>
                  <xsd:restriction base="oval-def:EntityStateStringType">
                        <xsd:enumeration value="DEGRADED">
                              <xsd:annotation>
                                    <xsd:documentation>The instance is enabled and running or available to run. The instance, however, is functioning at a limited capacity in comparison to normal operation.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="DISABLED">
                              <xsd:annotation>
                                    <xsd:documentation>The instance is disabled.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="MAINTENANCE">
                              <xsd:annotation>
                                    <xsd:documentation>The instance is enabled, but not able to run. Administrative action is required to restore the instance to offline and subsequent states.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="LEGACY-RUN">
                              <xsd:annotation>
                                    <xsd:documentation>This state represents a legacy instance that is not managed by the service management facility. Instances in this state have been started at some point, but might or might not be running.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="OFFLINE">
                              <xsd:annotation>
                                    <xsd:documentation>The instance is enabled, but not yet running or available to run.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="ONLINE">
                              <xsd:annotation>
                                    <xsd:documentation>The instance is enabled and running or is available to run.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value="UNINITIALIZED">
                              <xsd:annotation>
                                    <xsd:documentation>This is the initial state for all service instances.</xsd:documentation>
                              </xsd:annotation>
                        </xsd:enumeration>
                        <xsd:enumeration value=""/>
                  </xsd:restriction>
            </xsd:simpleContent>
      </xsd:complexType>
</xsd:schema>
